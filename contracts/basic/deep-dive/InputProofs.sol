// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.24;

import { FHE, euint8, externalEuint8 } from "@fhevm/solidity/lib/FHE.sol";
import { ZamaEthereumConfig } from "@fhevm/solidity/config/ZamaConfig.sol";

/**
 * @title InputProofs
 * @notice Demonstrates input proofs in FHEVM and why they are essential.
 * @dev Input proofs ensure that encrypted values submitted by users are:
 *      1. Properly encrypted with the network's public key
 *      2. Within valid type bounds (e.g., euint8 is 0-255)
 *      3. Generated by a legitimate encryption process
 *
 *      Without input proofs, malicious users could submit invalid ciphertexts
 *      that could cause undefined behavior or security vulnerabilities.
 */
contract InputProofs is ZamaEthereumConfig {
  euint8 private _verifiedValue;
  bool public hasStoredValue;

  event ValueStored(address indexed sender);

  // solhint-disable-next-line no-empty-blocks
  constructor() {}

  /**
   * @notice Store an encrypted value with proper input proof verification.
   * @dev The inputProof parameter is crucial - it cryptographically proves
   *      that the encrypted value was created correctly.
   *
   *      FHE.fromExternal() performs the following:
   *      1. Verifies the input proof against the ciphertext
   *      2. Converts the external handle to an internal handle
   *      3. Rejects invalid or malformed ciphertexts
   *
   * @param encryptedInput The encrypted value handle
   * @param inputProof The cryptographic proof of valid encryption
   */
  function storeWithProof(externalEuint8 encryptedInput, bytes calldata inputProof) external {
    // FHE.fromExternal verifies the proof and converts to internal handle
    // If proof is invalid, this will revert
    _verifiedValue = FHE.fromExternal(encryptedInput, inputProof);

    // Grant permission to the contract
    FHE.allowThis(_verifiedValue);
    FHE.allow(_verifiedValue, msg.sender);

    hasStoredValue = true;
    emit ValueStored(msg.sender);
  }

  /**
   * @notice Store multiple values demonstrating batch proof verification.
   * @dev Each value needs its own handle but can share an inputProof
   *      when encrypted together in a single createEncryptedInput call.
   */
  function storeMultipleWithProof(
    externalEuint8 valueA,
    externalEuint8 valueB,
    bytes calldata inputProof
  ) external {
    // Both values are verified with the same proof
    euint8 internalA = FHE.fromExternal(valueA, inputProof);
    euint8 internalB = FHE.fromExternal(valueB, inputProof);

    // Store sum as the verified value
    _verifiedValue = FHE.add(internalA, internalB);

    FHE.allowThis(_verifiedValue);
    FHE.allow(_verifiedValue, msg.sender);

    hasStoredValue = true;
  }

  function getValue() public view returns (euint8) {
    return _verifiedValue;
  }
}
